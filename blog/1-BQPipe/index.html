<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <title id="title">FSDD - BigQuery Pipe Syntax: Cleaner SQL</title>
    <link type="text/css" rel="stylesheet" href="/style.css">
    <link type="text/css" rel="stylesheet" href="/highlight.css">
    
  <style>
    #prev-next {
     display: flex;
     flex-direction: row;
     justify-content: space-between;
     margin-top: 40px;
    }

    figure {
      align-self: center;
      text-align: center;
      font-style: italic;
    }

    .post {
      display:flex;
      flex-direction: column;
    }
  </style>

  </head>
  <body id="body">
    <h1 class="site-title">The Full Stack Data Dev</h1>
    <nav>
      <a href="/">Home</a>
       &nbsp; • &nbsp;
      <a href="/about/">About</a>
       &nbsp; • &nbsp;
      <a href="/blog/">Blog</a>
    </nav>

    
  <h1>BigQuery Pipe Syntax: Cleaner SQL</h1>
  <div class="post"><h1>Introduction</h1><p>This document is intended to highlight the benefits of BigQuery’s Pipe syntax SQL and convince users for adoption. If you’re not familiar with Pipe syntax, you may consider starting from a <a href="#comparison">later section</a> to see some simple code side-by-side with Google standard SQL.</p><p>No contrived examples, just pure real-world use cases.</p><p>Here are some more comprehensive resources if you find the examples here insufficient:</p><ul><li>Official <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/pipe-syntax" target="_blank">documentation</a> for Pipe syntax:</li><li>Conference paper introducing Pipe syntax: <a href="https://research.google/pubs/sql-has-problems-we-can-fix-them-pipe-syntax-in-sql/" target="_blank">https://research.google/pubs/sql-has-problems-we-can-fix-them-pipe-syntax-in-sql/</a></li></ul><p>If I had to summarise the benefits of Pipe syntax SQL in a few bullet points, it would be:</p><ul><li>Improved guarantees on table cardinality</li><li>Stronger integration with templating languages (i.e. Jinja in dbt)</li><li>Improved readability from:<ul><li>Fewer CTEs that are more deliberately named</li><li>Concise multi-level aggregation</li><li>Concise sequential transforms</li></ul></li><li>Improved debugging experience in BigQuery console</li></ul><h2>Game-changer improvements</h2><p>Easier to transform arrays of structs</p><p>Consider a table with an array of structs as follows.</p><p>Sample table</p><p>– 1 row = 1 patient with an array of historical weight/height measurements WITH existing_logic AS ( SELECT 1 AS patient_id, [ STRUCT(70 AS weight, 1.75 AS height), – weight:kg, height:m STRUCT(71 AS weight, 1.75 AS height) ] AS history UNION ALL SELECT 2 AS patient_id, [ STRUCT(64 AS weight, 1.65 AS height) ] AS history )</p><p>SELECT * FROM existing_logic</p><p>Suppose we are now tasked to augment the history array by adding (BMI = weight / height^2) for each historical record. E.g. final table should appear as follows.</p><p>Target state of table</p><p>There are many ways to achieve this in standard SQL, but we can broadly categorise them into 2 approaches:</p><p>Manipulate the arrays in place using a subquery</p><p>Unnest the arrays in top-level CTEs, perform the transform, and re-aggregate.</p><p>Let’s look at some example implementations using standard SQL.</p><p>Standard SQL (Approach 1)</p><p>Standard SQL (Approach 2)</p><p>WITH existing_logic AS ( – Existing transformations in model ), bmi AS ( SELECT * REPLACE ( ARRAY((                        – This is the start of the subquery SELECT AS STRUCT *, weight/POWER(height, 2) AS BMI, FROM UNNEST(history) )) AS history                  – This is the end of the subquery ) FROM existing_logic ), more_logic AS ( – Further transformations in model )</p><p>WITH existing_logic AS ( – Existing transformations in model ), bmi_unnest AS ( SELECT existing_logic.* REPLACE(h AS history), OFFSET FROM existing_logic, UNNEST(history) AS h WITH OFFSET ), bmi_compute AS ( SELECT * REPLACE( (SELECT AS STRUCT history.*, history.weight / POWER(history.height, 2) AS BMI ) AS history ) FROM bmi_unnest ), bmi_reagg AS ( SELECT * EXCEPT(OFFSET, history), ARRAY_AGG(history ORDER BY OFFSET) AS history FROM bmi_compute GROUP BY ALL               – Have fun debugging a SELECT * GROUP BY ALL ), more_logic AS ( – Further transformations in model )</p><p>Despite the first approach appearing shorter, it is typically considered more difficult to read since the reader needs to identify the start and end of subqueries among existing CTEs. This difficulty is greatly exacerbated by any logic that is more involved than a simple example computation and requires CTEs for sequential transformations.</p><p>The second approach is easier to read since all the CTEs are top-level and the reader doesn’t need to identify the start and end of nested subqueries. However, this improved readability comes at a cost:</p><p>Unnesting the array & re-aggregating destroys guarantees on the table cardinality. This makes the table more fragile to future code changes. Testing the table can help, but it’s difficult to provide any guarantees on table cardinality assuming it’s possible to test for this in the first place.</p><p>The re-aggregation can be done either by a SELECT * GROUP BY ALL for brevity (but difficult to debug), or by tediously listing all the grouping column.</p><p>Namespace pollution in top-level CTEs.</p><p>Consider now the Pipe Syntax variant.</p><p>Pipe Syntax</p><p>WITH existing_logic AS ( – Existing transformations in model ), bmi AS ( FROM existing_logic |> SET history = ARRAY(( FROM UNNEST(history) |> EXTEND weight/POWER(height, 2) AS BMI |> SELECT AS STRUCT * )) ), more_logic AS ( – Further transformations in model )</p><p>Let’s see how it addresses some of the concerns from the standard SQL variants:</p><p>Subqueries Pipe syntax introduces one nested subquery per array. Furthermore, complex transformations can just be chained before the final |> SELECT AS STRUCT * instead of using nested CTEs.</p><p>Table cardinality The cardinality of the top-level table is untouched.</p><p>Namespace pollution A single CTE can be used to encapsulate as many or as few transformations as deemed appropriate.</p><p>More powerful generic tests in dbt</p><p>See section below: <a href="https://rome2rio.atlassian.net/wiki/spaces/TIPS/pages/3511648257/BQ+Pipe+Syntax+SQL#metric_conserved" target="_blank">https://rome2rio.atlassian.net/wiki/spaces/TIPS/pages/3511648257/BQ+Pipe+Syntax+SQL#metric_conserved</a></p><div id="comparison"><h2><a class="" href="#comparison">Small conveniences</a></h2><p>Easier to identify references to previous CTEs</p><p>Consider the following example where cte3 references cte1.</p><p>In Standard SQL, the declaration cte3 AS can be many lines apart from the reference FROM cte1 if the SELECT list is long.</p><p>In Pipe syntax, the reference to cte1 is always within a few lines of cte3 AS.</p><p>Standard SQL</p><p>Pipe Syntax</p><p>WITH cte1 AS ( SELECT … FROM dataset.table ),</p><p>cte2 AS ( SELECT … FROM dataset.table2 ),</p><p>cte3 AS ( SELECT … FROM cte1 – this can be screens apart from cte3 )</p><p>SELECT … FROM cte3 JOIN cte2 USING(…)</p><p>WITH cte1 AS ( FROM dataset.table |> SELECT … ),</p><p>cte2 AS ( FROM dataset.table2 |> SELECT … ),</p><p>cte3 AS ( FROM cte1 – this appears immediatley below cte3 |> SELECT … )</p><p>FROM cte3 |> JOIN cte2 USING(…) |> SELECT …</p><p>Easier to identify changes in table cardinality (row-count)</p><p>Consider the following example where the table undergoes several transformations, each of which affect the final row count. In Standard SQL, the cardinality of the table changes 4 times due to the clauses UNNEST, WHERE, GROUP BY, and HAVING.</p><p>Standard SQL</p><p>Pipe Syntax</p><p>SELECT dim_1, dim_2, COUNTIF(some_criteria) AS metric_1, ARRAY_AGG(some_expression) AS metric_2, FROM dataset.table, UNNEST(array) AS a WHERE some_filter GROUP BY dim_1, dim_2 HAVING metric_1 > 0</p><p>FROM dataset.table, UNNEST(arr) AS a |> WHERE some_filter |> AGGREGATE COUNTIF(some_criteria) AS metric_1, ARRAY_AGG(some_expression) AS metric_2, GROUP BY dim_1, dim_2, |> WHERE metric_1 > 0</p><p>Some pain points in Standard SQL and how Pipe syntax helps:</p><p>If the SELECT list is very long, the dev has to scroll down quite far from the beginning of the CTE to find out how the cardinality has changed. In Pipe syntax, the dev immediately expects a change in cardinality upon coming across one of UNNEST, |> WHERE and |> AGGREGATE. For UNNEST, the team can choose to adopt the style of using |> CROSS JOIN UNNEST to denote an explicit change in cardinality.</p><p>Additional mental headspace is needed to determine the order in which the table cardinality changes due to each of the 4 clauses (note that QUALIFY also affects cardinality). In Pipe syntax, the order in which cardinality changes is explicit with each chained |>. The changes in cardinality are thus sequential and can be more easily reasoned about.</p><p>Easier multi-level aggregation</p><p>In Standard SQL, each level of aggregation needs a new CTE (or god forbid a nested subquery). In Pipe syntax, each additional level of aggregation is just another chain of |> AGGREGATE … GROUP BY … clause.</p><p>The appearance of AGGREGATE also gives immediate notice to the reader that the following logic is focused on aggregation. In Standard SQL, one would have to 1) read through a large list of dimensions until an aggregation function appears without an OVER clause or 2) scroll down to check for a GROUP BY clause.</p><p>Standard SQL</p><p>Pipe Syntax</p><p>WITH date_OnD AS ( SELECT Date, OCanonical, DCanonical,</p><pre><code>COUNT(1) AS metric1,
SUM(value) AS metric2,
</code></pre><p>FROM dataset.table GROUP BY Date, OCanonical, DCanonical )</p><p>SELECT Date,</p><p>SUM(metric1) AS metric1, SUM(metric2) AS metric2,</p><p>ARRAY_AGG(STRUCT( OCanonical, DCanonical, metric1, metric2 ) LIMIT 10) AS Examples FROM date_OnD GROUP BY Date</p><p>FROM dataset.table |> AGGREGATE COUNT(1) AS metric1, SUM(value) AS metric2, GROUP BY Date, OCanonical, DCanonical |> AGGREGATE SUM(metric1) AS metric1, SUM(metric2) AS metric2,</p><pre><code>ARRAY_AGG(STRUCT(
  OCanonical,
  DCanonical,
  metric1,
  metric2
) LIMIT 10) AS Examples
</code></pre><p>GROUP BY Date</p><p>Easier EXCEPT and REPLACE</p><p>The equivalent of SELECT * EXCEPT () and SELECT * REPLACE () are now |> DROP and |> SET, respectively. Some niceties:</p><p>Trailing commas makes it easy to toggle comments on these lines when developing code,</p><p>The syntax for SET makes it very obvious which column is being replaced, as opposed to the REPLACE syntax which requires the dev to scan for the correct AS keyword (this can be extremely tedious when the column being replaced has struct fields being renamed).</p><p>Standard SQL</p><p>Pipe Syntax</p><p>SELECT</p><ul><li>EXCEPT ( drop_1, drop_2 ) REPLACE( UDF1(col_1) AS col_1, STRUCT( DATE(col_2.Timestamp) AS Date, col_2.Uid AS Aqid ) AS col_2 ) FROM dataset.table</li></ul><p>FROM dataset.table |> DROP drop_1, drop_2, – trailing comma! |> SET col_1 = UDF1(col_1), col_2 = STRUCT( DATE(col_2.Timestamp) AS Date, col_2.Uid AS Aqid ), – trailing comma!</p><p>Easier to manage sequential changes in column definitions</p><p>Following on the discussion of REPLACE and SET above, there’s a common pattern where data needs to be processed one column at a time (e.g. deviceCategory needs to be cleaned before it can be used to determine R2rFrontEnd).</p><p>The brevity of the code speaks for itself.</p><p>Standard SQL</p><p>Pipe Syntax</p><p>WITH raw AS ( SELECT col_1, col_2, col_3, FROM dataset.table ),</p><p>new_col1 AS ( SELECT * REPLACE ( UDF1(col_1) AS col_1 ) FROM raw ),</p><p>new_col2 AS ( SELECT * REPLACE ( UDF2(col_1, col_2) AS col_2 – depends on new col_1 ) FROM new_col2 ),</p><p>new_col3 AS ( SELECT * REPLACE ( UDF3(col_2, col_3) AS col_3 – depends on new col_2 ) FROM new_col2 )</p><p>SELECT * FROM new_col3</p><p>FROM dataset.table |> SET col_1 = UDF1(col_1) |> SET col_2 = UDF2(col_1, col_2) – depends on new col_1 |> SET col_3 = UDF3(col_2, col_3) – depends on new col_2</p><p>Cleaner Aggregation</p><p>In Standard SQL, dimensions and metrics can be in arbitrary order in the SELECT statement and the column names need to be manually duplicated in the GROUP BY statement if not using GROUP BY 1, 2 … or GROUP BY ALL.</p><p>When developing code, this becomes time consuming when:</p><p>a column name needs to be renamed in both the SELECT and GROUP BY clauses,</p><p>a column needs to be added/removed from GROUP BY when a dimension becomes a metric or vice-versa,</p><p>debugging a column that should have been aggregated but wasn’t due to using GROUP BY ALL.</p><p>In Pipe syntax, the separation of metrics and dimensions is demarcated by the GROUP BY keywords. Renaming of grouping columns becomes trivial.</p><p>Note 1: Pipe syntax allows a trailing comma for the final column in GROUP BY which makes it easy to reorder grouping columns.</p><p>Note 2: Pipe syntax doesn’t allow GROUP BY ALL. This may sound like an inconvenience as more lines of code might be needed, but there’s no actual change since the code is just being moved from SELECT to GROUP BY. There’s also the added benefit of the code being more explicit about what’s being grouped.</p><p>Standard SQL</p><p>Pipe Syntax</p><p>WITH group_by_column_example AS ( SELECT dim_1, dim2 AS dim_2,</p><pre><code>COUNT(1) AS metric,
</code></pre><p>FROM dataset.table GROUP BY dim_1, dim_2 ),</p><p>group_by_all_example AS ( SELECT dim1,</p><pre><code>COUNT(1) AS metric1,
metric2, -- Forgot to aggregate this metric
</code></pre><p>FROM dataset.table GROUP BY ALL )</p><p>WITH group_by_column_example AS ( FROM datset.table |> AGGREGATE COUNT(1) AS metric, GROUP BY dim1, dim2 AS dim_2, – Column alias + trailing comma. Awesome! ),</p><p>group_by_all_example AS ( FROM dataset.table |> AGGREGATE COUNT(1) AS metric1, metric2, – BQ Engine will remind you to aggregate this GROUP BY dim1 )</p><p>Common patterns</p><p>UNION ALL and EXCEPT DISTINCT</p><p>FROM table1_v1 |> UNION ALL (FROM table1_v2), (FROM table1_v3), |> EXCEPT DISTINCT (FROM table1_obsolete)</p><p>Selecting the schema columns at the end</p><p>A common pattern in our current codebase is to have our first CTE extract the columns we need, and then have all the subsequent CTEs add/drop columns as needed while processing business logic, making liberal use of the patterns * EXCEPT and * REPLACE.</p><p>One consequence of this is that table schemas have columns being ordered in non-intuitive ways (i.e. in whatever order columns were added in CTEs). This adds complexity when tables are obsoleted by new implementations and there needs to be a union of datasets to match schemas (e.g. <a href="https://github.com/rome2rio/cloudlake-dbt/blob/e82cf897ab8c341c8f3a64f85dc911e657019666/models/productMetrics/productMetrics-Sessions.sql" target="_blank">https://github.com/rome2rio/cloudlake-dbt/blob/e82cf897ab8c341c8f3a64f85dc911e657019666/models/productMetrics/productMetrics-Sessions.sql</a>, <a href="https://github.com/rome2rio/cloudlake-dbt/blob/e82cf897ab8c341c8f3a64f85dc911e657019666/models/monitoring/monitoring-UserExits.sql" target="_blank">https://github.com/rome2rio/cloudlake-dbt/blob/e82cf897ab8c341c8f3a64f85dc911e657019666/models/monitoring/monitoring-UserExits.sql</a>, <a href="https://github.com/rome2rio/cloudlake-dbt/blob/e82cf897ab8c341c8f3a64f85dc911e657019666/models/bookings/bookings-LegacyUserBookings.sql" target="_blank">https://github.com/rome2rio/cloudlake-dbt/blob/e82cf897ab8c341c8f3a64f85dc911e657019666/models/bookings/bookings-LegacyUserBookings.sql</a>)</p><p>With Pipe syntax, most business logic can be processed in pipes |> instead of in CTEs. This isolates the concern of having to reorder new columns and drop old columns to match schemas while processing other logic. The concern of column orders to match schemas can be containerised into the final |> SELECT pipe.</p><p>Standard SQL</p><p>Pipe Syntax</p><p>WITH new AS ( SELECT * FROM dataset.table ),</p><p>business_logic AS ( SELECT * EXCEPT (new_col) REPLACE ( CAST(UDF(old_col) AS DATETIME) AS old_col ), FROM new<br>),</p><p>reorder_columns AS ( SELECT * EXCEPT(old_col), old_col, – make sure old_col appears last FROM business_logic ),</p><p>legacy AS ( SELECT * FROM dataset.table_legacy )</p><p>SELECT * FROM legacy UNION ALL SELECT * FROM reorder_columns</p><p>{%- set legacy_schema %} col_1, col_2, … {%- enset}</p><p>WITH new AS ( FROM dataset.table |> DROP new_col |> SET old_col = CAST(UDF(old_col) AS DATETIME) |> SELECT {{ legacy_schema }} ),</p><p>legacy AS ( FROM dataset.table_legacy |> SELECT {{ legacy_schema }} )</p><p>FROM legacy |> UNION ALL (FROM new)</p></div></div>
  <div id="prev-next">
    <div></div>
    <div>
      <a href="/blog/2-dbt-testing/">
        <span>Data quality testing in dbt</span>
        →
      </a>
    </div>
  </div>


    <footer>
      <hr>
    </footer>
  </body>
</html>
